1
00:10:42,680 --> 00:10:43,679
Hello and welcome.

2
00:10:43,679 --> 00:10:47,870
Or as I would say in Denmark,
"Goddag og velkommen"

3
00:10:47,870 --> 00:10:51,790
The title of the
session is Unity Hacks

4
00:10:51,790 --> 00:10:55,630
I'm going to start off
by introducing myself.

5
00:10:55,630 --> 00:10:57,529
My name is Emil Johansen

6
00:10:57,529 --> 00:11:02,320
I usually go by the
nickname of AngryAnt online.

7
00:11:02,320 --> 00:11:04,900
That's a photo of me

8
00:11:04,900 --> 00:11:11,149
I'm a game developer at Unity, which means I work
with the different developer teams to ensure that

9
00:11:11,149 --> 00:11:17,199
all our different features work well
together, and I do internal demo work.

10
00:11:17,199 --> 00:11:22,070
Some of which goes into standard
assets and that sort of thing.

11
00:11:22,070 --> 00:11:25,640
And I specialize in AI as well.

12
00:11:25,640 --> 00:11:28,440
I've been at Unity for four years.

13
00:11:28,440 --> 00:11:34,100
And for the past five years, I've
worked with Unity the product.

14
00:11:34,100 --> 00:11:42,490
And before doing so, I worked with Unreal
Engine 3, CryEngine 1, and Renderware

15
00:11:43,230 --> 00:11:46,260
I live in Copenhagen, Denmark.

16
00:11:46,260 --> 00:11:53,060
And in my spare time, I create some
additional projects such as Path and Behave.

17
00:11:53,060 --> 00:11:58,740
These are AI middleware
solutions for Unity.

18
00:11:58,740 --> 00:12:01,179
This is my second time around on the Asia Tour.

19
00:12:02,120 --> 00:12:09,380
Last year, I did a talk called "Rapid
Network and AI-Ready Game Development."

20
00:12:09,380 --> 00:12:12,100
It's a very long title and
I'm sorry about that, but

21
00:12:12,100 --> 00:12:14,740
I couldn't come up with a shorter one.

22
00:12:15,540 --> 00:12:23,660
So this talk is kind of the practical
counterpart of that talk from last year.

23
00:12:24,660 --> 00:12:26,480
My website is AngryAnt.com.

24
00:12:26,480 --> 00:12:32,770
And I gather some of my code snippets, examples, projects and

25
00:12:32,770 --> 00:12:39,160
videos such as the recording of last year's talk.

26
00:12:39,160 --> 00:12:41,380
This is my daughter, Lily.

27
00:12:41,380 --> 00:12:45,810
And today I'm wearing a
different set of glasses.

28
00:12:45,810 --> 00:12:52,950
Not out of a fashion choice, but because on my birthday
in February, she chose to tear the old pair apart.

29
00:12:52,950 --> 00:12:56,380
So she's a feisty little devil.

30
00:12:58,370 --> 00:13:02,530
Obviously, who can blame
her with those looks.

31
00:13:03,519 --> 00:13:08,270
Let's jump onto the contents of this talk.

32
00:13:09,790 --> 00:13:14,670
Unlike some of the other talks today, I've tried to

33
00:13:14,670 --> 00:13:19,095
make this talk more of a
fun playful kind of thing.

34
00:13:19,096 --> 00:13:23,540
I hope that you can take some of the
examples I'm going to show here

35
00:13:23,540 --> 00:13:28,120
and if not use them directly.

36
00:13:29,560 --> 00:13:32,640
They are designed for that, but
I really hope that you can

37
00:13:32,640 --> 00:13:36,430
take some of the ideas and approach
and hopefully be inspired by that

38
00:13:36,430 --> 00:13:41,410
to create your own Unity hacks.

39
00:13:42,130 --> 00:13:46,510
So part of the theme here is
Mission: Let's Just Ship This Thing.

40
00:13:46,510 --> 00:13:52,120
Which is where is this ties in
with last year's talk as well.

41
00:13:53,680 --> 00:14:00,380
One part of that is to minimize your
needed workload by working smart.

42
00:14:01,430 --> 00:14:07,660
And part of that is data and code reuse, which
I'll go in and demonstrate in a few ways.

43
00:14:10,270 --> 00:14:13,740
And another part is shaving iteration
time as closely as possible

44
00:14:13,740 --> 00:14:16,650
by managing your workflow.

45
00:14:18,400 --> 00:14:20,170
We'll also get into that.

46
00:14:23,070 --> 00:14:28,350
So, in regards to shaving iteration time,
that means adapting your workflow

47
00:14:28,950 --> 00:14:33,300
and getting relevant feedback
data as quickly as possible

48
00:14:34,690 --> 00:14:40,320
and reducing the amount
of manual work required.

49
00:14:41,680 --> 00:14:46,700
In general, I'm trying to communicate
a theme of "Good Enough" can ship

50
00:14:47,980 --> 00:14:52,130
in the pursuit of rapid
game development.

51
00:14:58,120 --> 00:15:02,870
The way I'm going to go about
presenting this content is

52
00:15:02,870 --> 00:15:06,930
I'll show a whole lot
of cool hacks and code

53
00:15:06,930 --> 00:15:09,910
I'm going to show some good examples
of examples of data reuse

54
00:15:09,910 --> 00:15:12,010
and a lot of editor scripting.

55
00:15:20,130 --> 00:15:25,400
So let's start off by looking at
some examples from the runtime.

56
00:15:25,400 --> 00:15:29,960
And initially, I want to touch on
the subject of animation curves.

57
00:15:31,140 --> 00:15:36,700
The initial example here is
directional speed of character.

58
00:15:36,700 --> 00:15:43,400
In many games you have a sort of humanoid
character or some avatar you need to move around.

59
00:15:43,401 --> 00:15:48,130
This avatar will have a
facing and a heading.

60
00:15:48,130 --> 00:15:52,970
By default, when the facing is equal
to heading, you'll want to

61
00:15:52,970 --> 00:15:57,530
move that character by the top speed.

62
00:15:57,530 --> 00:16:07,870
When at an angle, you'll usually want to, within the first
twenty degrees or so, keep this angle or this constant speed.

63
00:16:07,870 --> 00:16:10,870
Though when you start
moving more sideways

64
00:16:10,870 --> 00:16:18,740
and particularly moving directly back,
you want to weight the base speed.

65
00:16:18,740 --> 00:16:22,290
And of course this
works mirrored as well.

66
00:16:23,490 --> 00:16:27,460
So one way I propose doing
this with animation curves

67
00:16:27,460 --> 00:16:33,910
is to divide the angle, or basically scale the
angle between the heading in the facing

68
00:16:33,910 --> 00:16:37,740
between 0 and 180 degrees

69
00:16:37,740 --> 00:16:40,050
and normalize that.

70
00:16:40,050 --> 00:16:47,530
So this allows you to define an animation curve
where you can use the height of the curve to

71
00:16:47,530 --> 00:16:50,620
define the scale of the speed.

72
00:16:53,420 --> 00:16:58,750
So in this example, I'm showing showing
the curve that I demonstrated earlier

73
00:16:58,750 --> 00:17:07,319
where you see initially, the curve - as we're close
to zero - moving forward, the speed remains 1.

74
00:17:07,319 --> 00:17:16,190
And as we go further towards 1 or 180
degrees, we go down to half-speed.

75
00:17:16,190 --> 00:17:20,509
Showing this in a real environment.

76
00:17:21,370 --> 00:17:24,829
You can see if I move forward,
I have quite a lot of speed.

77
00:17:24,829 --> 00:17:28,210
You can also see the speed indicator
in the upper-right corner.

78
00:17:28,210 --> 00:17:31,590
But as I move around, I get

79
00:17:31,590 --> 00:17:44,820
different speeds based on how the heading
moves around compared to the facing.

80
00:17:44,820 --> 00:17:46,960
So, looking at a script.

81
00:17:46,960 --> 00:17:49,370
The script I'm using for this is fairly simple.

82
00:17:49,370 --> 00:17:53,350
Actually, the part that takes
up the most space is just

83
00:17:53,350 --> 00:17:59,410
where I take the input and formulate
that into a directional vector.

84
00:17:59,410 --> 00:18:01,960
So this is just getting
the input axis.

85
00:18:02,980 --> 00:18:08,890
Then in each update, I just, for this
example, translate the transform

86
00:18:08,890 --> 00:18:12,730
where I translate it by
my directional vector

87
00:18:13,820 --> 00:18:16,920
the default speed, which is at 5.

88
00:18:18,489 --> 00:18:22,760
Since it's an update, of course
it's scaled by Time. DeltaTime.

89
00:18:22,760 --> 00:18:32,860
The interesting bit is where I get the angle between
the forward vector of the transform and my direction

90
00:18:32,860 --> 00:18:37,029
I divide that by 180,
thus normalizing it.

91
00:18:37,029 --> 00:18:42,700
And then I evaluate my animation
curve called Speed Scale

92
00:18:42,700 --> 00:18:50,430
which I have made public so I can define it
exactly how it needs to look in the editor.

93
00:18:50,430 --> 00:19:03,020
By calling evaluate, I get the height
of the curve at my given time index.

94
00:19:07,570 --> 00:19:15,060
So another example of animation curves is
using it for camera blending and clamping.

95
00:19:15,060 --> 00:19:21,789
In the same setup you have a character
with heading or a facing

96
00:19:21,789 --> 00:19:25,780
and a camera observing the
top of the character

97
00:19:25,780 --> 00:19:29,789
usually looking a bit over
the head of the character.

98
00:19:29,789 --> 00:19:35,200
A fairly a common set up is that you want
to clamp the movement of the camera

99
00:19:35,200 --> 00:19:38,570
between an upper angle
and a lower angle

100
00:19:38,570 --> 00:19:47,920
in comparison to the reverse. Or basically,
the backwards facing vector of the character.

101
00:19:47,920 --> 00:19:56,500
And you commonly also have a bit of logic to handle
clipping of objects, so you move the camera closer.

102
00:20:02,429 --> 00:20:07,399
In this case I'm not using an
animation curve between 0 and 1

103
00:20:07,399 --> 00:20:09,910
because I want additional data.

104
00:20:09,910 --> 00:20:12,360
I actually want two
data points out of this

105
00:20:12,360 --> 00:20:17,160
I want to know what the lower
and upper maximum is

106
00:20:17,160 --> 00:20:22,850
as well as I want to know what the
update speed of the camera should be.

107
00:20:22,850 --> 00:20:27,170
So I'm using the time index of the
animation curve to define the

108
00:20:27,170 --> 00:20:30,140
upper and lower bounds in degrees.

109
00:20:30,140 --> 00:20:33,799
So this basically says that
it can go 20 degrees below

110
00:20:33,799 --> 00:20:39,390
the backwards facing vector,
and 30 degrees above.

111
00:20:39,390 --> 00:20:46,669
And then I use the height to specify how
quickly it can move toward these extremes.

112
00:20:46,669 --> 00:20:56,080
The effect of this is that as we are above medium,
and continue to move forward or upward

113
00:20:56,080 --> 00:20:59,390
the camera will update
slower and slower.

114
00:20:59,390 --> 00:21:03,500
So instead of getting a hard
clamp, we get a nice soft

115
00:21:03,500 --> 00:21:06,610
lead into that clamping

116
00:21:06,610 --> 00:21:10,030
and the same in reverse.

117
00:21:10,030 --> 00:21:13,860
So if we look at the same example,
and I move the camera up

118
00:21:13,860 --> 00:21:15,980
I keep a constant speed of the cursor.

119
00:21:15,980 --> 00:21:18,059
But even so

120
00:21:18,059 --> 00:21:21,830
it moves slowly in the end.

121
00:21:23,309 --> 00:21:25,950
Taking a look at the code for this

122
00:21:25,950 --> 00:21:31,120
this is slight more complex, so I'm
going to just focus on a few key points.

123
00:21:31,120 --> 00:21:36,260
Initially, I define my animation
curve called "VerticalSpan"

124
00:21:36,260 --> 00:21:41,110
where I set the default values to
start from the keyframe, minus 20

125
00:21:41,110 --> 00:21:44,180
and end on the keyframe, 30.

126
00:21:45,140 --> 00:21:50,880
And initially I just set it to have a start and
end value of 1, so this is just a flat curve.

127
00:21:51,850 --> 00:22:02,840
I then use the editor to go in and add this
scale on either end to get that bell shape.

128
00:22:02,840 --> 00:22:11,740
Then I have a few simple properties for figuring out a
normalized position on the arc that the camera can move on.

129
00:22:11,740 --> 00:22:15,350
And finally, when I update my camera,

130
00:22:15,350 --> 00:22:21,970
I have a "targetHorizontalRotation"
which an input scripts provides for me.

131
00:22:21,970 --> 00:22:30,350
I then initially figure out the speed at which should
update this camera position or camera rotation.

132
00:22:31,440 --> 00:22:35,149
If the vertical position
is above half,

133
00:22:35,149 --> 00:22:38,309
and we're continuing up,

134
00:22:38,309 --> 00:22:44,860
then I take my update speed and scale
it by the evaluated vertical span

135
00:22:44,860 --> 00:22:53,280
using the angle as the index, because
remember we used angles for the X-axis.

136
00:22:54,760 --> 00:22:58,210
If we are up, but we're not
continuing further up

137
00:22:58,210 --> 00:23:04,560
this logic will not get executed, so therefore
we will just keep the regular update speed.

138
00:23:04,560 --> 00:23:10,539
And the same is valid for the reverse.

139
00:23:10,539 --> 00:23:13,090
So then I update my rotation.

140
00:23:13,090 --> 00:23:19,515
And I apply the second step of checking
if my angle goes beyond either extreme.

141
00:23:19,516 --> 00:23:25,340
So I clamp it and that's it.

142
00:23:33,880 --> 00:23:35,640
So just to recap.

143
00:23:35,640 --> 00:23:41,680
Animation curves are basically
just a number of curved 2D values.

144
00:23:41,680 --> 00:23:46,959
So while they are most useful for, and
initially designed for animation

145
00:23:46,959 --> 00:23:50,440
and these two examples were
probably quite animation related

146
00:23:50,440 --> 00:23:53,040
you can basically use them
for just about anything.

147
00:23:53,040 --> 00:23:58,660
Since you can just sample the data at
any point; it's just simple 2D data.

148
00:23:58,660 --> 00:24:04,240
One example, I saw a guy on Twitter
recently who had used it to

149
00:24:04,240 --> 00:24:13,610
he used an animation curve to define the difficulty level
of his different scenes, which is a very nice use case.

150
00:24:13,610 --> 00:24:16,340
So anything from game logic to AI

151
00:24:16,340 --> 00:24:21,620
whatever you can come up with,
we need a set of 2D values.

152
00:24:21,620 --> 00:24:26,299
Especially because the curves are
visually editable in the editor, so

153
00:24:26,299 --> 00:24:31,980
you can, very easily, instead of
spending a lot of time iterating over

154
00:24:31,980 --> 00:24:39,240
some magical numbers, or a certain bit of
code that does something programmatically

155
00:24:39,240 --> 00:24:42,420
you can basically just
go, "Here's a curve,"

156
00:24:42,420 --> 00:24:45,980
and send it to your
game designer or artist

157
00:24:45,980 --> 00:24:51,770
and go, "Okay, so you go ahead and tweak this."
And they can do this in play mode.

158
00:24:51,770 --> 00:24:56,230
It's a very nice way to reduce iteration time

159
00:24:56,230 --> 00:25:00,830
and offset a task that really should
belong to the game designer or an artist

160
00:25:00,830 --> 00:25:08,409
offset that away from the programmer who
would otherwise become a bottleneck.

161
00:25:13,320 --> 00:25:18,320
Additionally, it's a visual thing, so it's
easy to debug and understand what's going on.

162
00:25:19,190 --> 00:25:23,340
For one example, I used
an animation curve

163
00:25:23,340 --> 00:25:26,970
not as the source of the data,
but as a visual tool

164
00:25:26,970 --> 00:25:36,929
because I had some programmatic animation going on, and
I didn't quite understand why it behaved the way it did.

165
00:25:36,929 --> 00:25:41,890
So my solution for it was to, at
runtime, create an animation curve

166
00:25:41,890 --> 00:25:46,390
and every frame, or every
N-number frames

167
00:25:46,390 --> 00:25:50,770
insert an animation key,
key framing it

168
00:25:50,770 --> 00:25:56,450
so I could visually see what was going on,
and that helped me to very quickly

169
00:25:56,450 --> 00:26:04,760
go in and change that bit of
logic that was misbehaving.

170
00:26:11,680 --> 00:26:15,300
Moving onto data reuse

171
00:26:15,300 --> 00:26:20,220
in this example going to talk
a bit about a stealth system.

172
00:26:20,990 --> 00:26:25,370
So, in many games where you have a dark environment

173
00:26:25,370 --> 00:26:30,110
it's common that you have some sort of sneak mechanic where

174
00:26:30,110 --> 00:26:36,740
the level of lighting you're in determines
how well an enemy character can see you.

175
00:26:37,880 --> 00:26:41,639
And the way this is usually done is
by setting up these trigger volumes

176
00:26:43,020 --> 00:26:48,330
for determining that at this point you're in
shadow, but at this point you're not.

177
00:26:48,330 --> 00:26:53,760
This has several problems because
these basically give you two

178
00:26:53,760 --> 00:26:57,649
pieces of data to update every time
you make a change to your level.

179
00:26:57,649 --> 00:27:02,910
Not only do you have to change your
lighting, but also these logical triggers.

180
00:27:02,910 --> 00:27:09,450
It also gives a fairly bad
user experience because when

181
00:27:09,450 --> 00:27:15,350
the character is in this position, he's in
light, but when he's there, he's in dark

182
00:27:15,350 --> 00:27:21,690
which is quite jarring
and strange for the user.

183
00:27:21,690 --> 00:27:30,110
Actually many games ship with having an out of
sync update where they update the lighting

184
00:27:30,110 --> 00:27:35,779
and they forget, in their rush to to finish the
game, they forget to update the logic triggers

185
00:27:35,779 --> 00:27:40,670
and then all of a sudden you
have a lot of very angry users.

186
00:27:46,810 --> 00:27:51,500
So what I've done in this case is
instead of this direct break

187
00:27:51,500 --> 00:27:56,950
I have a sliding scale for how
much in shadow the character is.

188
00:27:58,670 --> 00:28:03,000
Which I'm gonna show you how I do here.

189
00:28:28,789 --> 00:28:33,049
The way this works is basically in Unity 3.5, I believe

190
00:28:33,049 --> 00:28:36,190
we added the system of light probes.

191
00:28:36,190 --> 00:28:47,660
Initially, this system was added in order to give you
something that seems like realtime lighting using baked data.

192
00:28:47,660 --> 00:28:56,570
So you get them the nice realtime lighting feel using
baked global illumination without the runtime overhead.

193
00:28:56,570 --> 00:29:04,800
So what I do here is basically use the same system
to get just the basic lighting information out.

194
00:29:04,800 --> 00:29:10,010
Since we have full global illumination
here, I have all sorts of

195
00:29:10,010 --> 00:29:13,990
directional values as well, but I found
that for this use case, actually just

196
00:29:13,990 --> 00:29:19,200
getting the common
lighting is sufficient

197
00:29:19,200 --> 00:29:26,240
I then take some numbers which are
fitted to this particular level.

198
00:29:26,240 --> 00:29:32,119
So in this example, these are constant values, but
they should probably, in an actual use case, be

199
00:29:32,119 --> 00:29:36,850
per-level defined because each level's
lighting is a bit different, and

200
00:29:36,850 --> 00:29:40,610
the idea of what is shadow
and not is different.

201
00:29:40,610 --> 00:29:48,090
But I basically just scale the lighting between
these two values and normalize it.

202
00:29:48,090 --> 00:29:56,990
And that gives me a nice normalized value
of whether you're in shadow or not.

203
00:30:02,340 --> 00:30:06,670
So just to summarize, we are
reusing existing data here

204
00:30:06,670 --> 00:30:08,649
which means there's
no duplicated effort.

205
00:30:08,649 --> 00:30:13,560
You change your lighting,
you rebake, and that's it.

206
00:30:13,560 --> 00:30:20,279
It also means that what the user sees is
what he actually gets in terms of game logic.

207
00:30:20,279 --> 00:30:23,230
So there's no disconnect for the user.

208
00:30:23,230 --> 00:30:28,480
And it's high quality data unlike the the
simple trigger volumes, you can have

209
00:30:28,480 --> 00:30:31,139
much more varied
gameplay where maybe

210
00:30:31,139 --> 00:30:37,430
the AI has been implemented so it kind of almost
sees the character and goes closer to investigate

211
00:30:37,430 --> 00:30:40,740
and then you can maybe
move further into shadow.

212
00:30:42,250 --> 00:30:44,050
And it's very intuitive to maintain.

213
00:30:44,050 --> 00:30:48,090
You change the light, you hit bake, you're done.

214
00:30:49,020 --> 00:30:53,330
Finally, there's no runtime overhead for this.
This is using a system that's already there

215
00:30:53,331 --> 00:30:56,940
it's simply sampling between
some values and interpolating

216
00:30:57,240 --> 00:31:01,700
so it's extremely low-cost.

217
00:31:08,190 --> 00:31:14,070
I'm gonna show you a small
example of a menu set up here.

218
00:31:14,070 --> 00:31:16,519
So this is just a quick example menu

219
00:31:16,519 --> 00:31:21,700
with a main menu and some level
setup, settings, and so forth.

220
00:31:22,639 --> 00:31:28,890
It's not really exciting, but if we look at the
code, things start getting a bit more interesting.

221
00:31:28,890 --> 00:31:32,899
So the idea here is that
once the script starts up

222
00:31:32,899 --> 00:31:41,959
based on my "State enum" definition, I create
a dictionary indexed by this "State enum"

223
00:31:41,959 --> 00:31:45,590
pointing to action delicate handlers.

224
00:31:45,590 --> 00:31:54,460
So way this is built is basically that I used reflection
to find any function that matches the prefix "on"

225
00:31:56,100 --> 00:32:00,170
the name of the state, and
the postfix "MenuGUI"

226
00:32:00,170 --> 00:32:06,290
So for the default value of
"State. Main" I'll get

227
00:32:07,299 --> 00:32:14,580
a dictionary index of "State. Main"
pointing to function called "OnMainMenuGUI."

228
00:32:14,580 --> 00:32:17,630
This means the first
iteration of "onGUI"

229
00:32:18,590 --> 00:32:26,429
I call the delegate pointed to by the dictionary
indexed by the current state being "Main"

230
00:32:26,429 --> 00:32:32,810
That will invoke the
"OnMainMenuGUI" GUI handler.

231
00:32:32,810 --> 00:32:38,349
Switching between different menus is simply a matter
of changing the value of the state variable

232
00:32:38,349 --> 00:32:47,030
which will then either call on "LevelsMenuGUI,"
on "SettingsMenuGUI," or on "CreditsMenuGUI"

233
00:32:47,030 --> 00:32:55,230
This is a very straightforward
setup easily readable.

234
00:32:55,910 --> 00:33:00,340
Looking a bit on this: This is a
nice example code reuse where

235
00:33:00,340 --> 00:33:05,690
we basically, very easily limit
the points of failure on this.

236
00:33:05,690 --> 00:33:14,690
Either you have a mismatch between the function
name, and the enum name, or it will just work.

237
00:33:14,690 --> 00:33:16,700
It's a very natural syntax.

238
00:33:16,700 --> 00:33:22,110
You write the enums, you right the functions,
you can easily see what's going on.

239
00:33:25,410 --> 00:33:29,830
Moving onto an example or a
self-contained WebPlayer

240
00:33:29,830 --> 00:33:41,580
I'm just gonna try and do a quick live build of
it here, and see if everything breaks or not.

241
00:33:44,860 --> 00:33:55,750
This is a simpler example where I
have a bit of website JavaScript which

242
00:33:55,750 --> 00:33:59,390
sends a message back to my WebPlayer.

243
00:34:04,470 --> 00:34:07,090
Looking a bit into how
this script is set up

244
00:34:07,919 --> 00:34:11,819
I simply have a public
TextAsset variable

245
00:34:11,819 --> 00:34:19,219
and on start, I call "ExternalEval" using
text content of that text asset

246
00:34:19,219 --> 00:34:28,079
and I provide a JavaScript callback
method for JavaScript to call.

247
00:34:28,079 --> 00:34:32,459
If we look at JavaScript code for this.

248
00:34:44,429 --> 00:34:49,719
That's all the JavaScript in there.
It basically gets a reference to

249
00:34:49,719 --> 00:34:54,779
the WebPlayer, sends a message to this
game object called this function

250
00:34:54,779 --> 00:35:00,789
with the return value of the website
JavaScript function "prompt."

251
00:35:00,789 --> 00:35:07,299
So, very straightforward and easy to understand.

252
00:35:07,299 --> 00:35:09,569
If we continue here.

253
00:35:09,569 --> 00:35:14,879
The nice thing about this is that you have all the
relevant code contained within that project

254
00:35:14,879 --> 00:35:19,629
which means versioning becomes very straightforward.
You have no external dependencies.

255
00:35:19,629 --> 00:35:23,879
Whenever you make a change to
your website JavaScript

256
00:35:23,879 --> 00:35:33,119
you can vary easily couple that change set
with the relevant C# or Unity JavaScript code.

257
00:35:33,119 --> 00:35:43,439
It makes for easy testing and deployment because you
just have one project to build and run, and that's it.

258
00:35:45,409 --> 00:35:48,940
So, just reiterating on
rapid game development.

259
00:35:48,940 --> 00:35:54,709
Last year's talk by this title,

260
00:35:55,529 --> 00:36:00,719
it's available on AngryAnt.com/videos.

261
00:36:04,109 --> 00:36:08,929
With this talk in baggage

262
00:36:08,929 --> 00:36:17,129
this other talk will probably
be a bit more useful.

263
00:36:17,129 --> 00:36:23,619
Moving on to the editor side of things,
and initially looking at importers.

264
00:36:24,749 --> 00:36:27,999
My first example is about package setup.

265
00:36:27,999 --> 00:36:35,499
This is for an asset store package or at bit of
code that you reuse a lot between different projects.

266
00:36:36,569 --> 00:36:41,470
If you have any non-script dependencies
which aren't a texture or something,

267
00:36:41,470 --> 00:36:47,219
something which is the project setup like
player settings, or whatever that might be,

268
00:36:47,219 --> 00:36:52,319
this is what I'm addressing here.

269
00:36:52,319 --> 00:36:54,139
As an example:

270
00:36:54,139 --> 00:37:02,599
I have a custom asset which contains
some tags, layers, and input axis.

271
00:37:02,599 --> 00:37:09,249
This is quite useful if you have a character
controller which requires a specific input setup

272
00:37:09,249 --> 00:37:12,059
and you want to share
this between projects.

273
00:37:12,059 --> 00:37:18,539
Having a bit of code which uses the serialization
system which Tim Cooper talked about earlier

274
00:37:20,019 --> 00:37:24,939
to reconfigure your Unity setup to
match what this script requires.

275
00:37:26,579 --> 00:37:29,319
It's a very nice solution.

276
00:37:29,319 --> 00:37:39,809
As an example here, if I add another layer
to my custom asset here, I can hit import

277
00:37:39,809 --> 00:37:47,029
and go to my layers, and you
can see it has been added here.

278
00:37:47,029 --> 00:37:58,339
And in the same way, if I change the layer,
and go re-export it, it updates here.

279
00:37:58,339 --> 00:38:07,869
This allows me to very easily
move dependencies around.

280
00:38:08,269 --> 00:38:11,809
Moving onto workflow automation.

281
00:38:11,809 --> 00:38:17,889
The main goal here is to eliminate
common, repetitive tasks.

282
00:38:17,889 --> 00:38:20,969
At the very core of it, it'll
boost your team morale.

283
00:38:22,009 --> 00:38:24,450
No one wants to do a lot
of the factory work.

284
00:38:25,470 --> 00:38:32,919
And it also speeds up your iteration
time since you can produce more.

285
00:38:35,289 --> 00:38:40,489
As an example here, I have an Android
plugin that I want to work with.

286
00:38:41,709 --> 00:38:53,189
Basically I wrote this piece of code the
first time I wanted to do Android plugins

287
00:38:53,189 --> 00:38:55,360
because my Java is not the best

288
00:38:55,360 --> 00:38:59,260
and I knew I would have to go through a
lot of iterations on this Java code

289
00:39:00,189 --> 00:39:01,660
and fix a lot of bugs.

290
00:39:01,660 --> 00:39:10,559
Basically the current workflow for doing an
Android plugin involves a lot of command line

291
00:39:10,559 --> 00:39:14,880
hand coding or hand execution.

292
00:39:16,179 --> 00:39:19,974
This is a very simple test which provides
a function that'll call back to.

293
00:39:19,975 --> 00:39:24,269
Unity just like the website
JavaScript we saw before.

294
00:39:27,479 --> 00:39:29,989
The way that I have this compiling

295
00:39:36,829 --> 00:39:40,809
I basically wanted the same kind of
workflow that I'm used to with C#

296
00:39:40,809 --> 00:39:43,899
so I wrote an asset post processor.

297
00:39:43,899 --> 00:39:55,109
What this allows me to do is find any file or handle
any file within the path "Assets/Plugins/Android/src"

298
00:39:56,159 --> 00:40:03,990
And if the extension of that is .java,
I want to compile all my Java code.

299
00:40:07,719 --> 00:40:13,059
The way I do this is basically by
using the .net process start info

300
00:40:13,059 --> 00:40:18,479
to launch the built-in
system Java compiler

301
00:40:18,479 --> 00:40:22,999
I parse in the Java files in my project

302
00:40:22,999 --> 00:40:26,849
the reference to the
Android jar file

303
00:40:26,849 --> 00:40:32,359
from the Android SDK, and the
Unity jar file, and so forth

304
00:40:33,489 --> 00:40:37,269
I also create the signature needed

305
00:40:37,269 --> 00:40:41,909
finally just build it into a
jar which I put in my project.

306
00:40:41,909 --> 00:40:47,609
The resulting workflow is basically
that I save my Java code

307
00:40:47,609 --> 00:40:49,949
which we can just quickly do here.

308
00:40:54,449 --> 00:41:02,449
Create a compiler error here
I get that compiler error in my console.

309
00:41:02,449 --> 00:41:13,649
And I can quickly go in and say, "Okay, this line,
go and change that," and there we go, it's compiled.

310
00:41:13,649 --> 00:41:21,659
So this means I can optimize my workflow
in a way that I'm used to working with.

311
00:41:21,659 --> 00:41:26,679
So moving onto a topic of bundles.

312
00:41:26,679 --> 00:41:31,089
Initially, what I want to talk a bit
about is the manifest for bundles.

313
00:41:31,089 --> 00:41:36,289
What I want to achieve here is, I
want to have a hands-off update approach

314
00:41:36,289 --> 00:41:41,899
whenever I change something in my bundle, I
don't want to have a lot of manual steps.

315
00:41:42,699 --> 00:41:47,229
And I want to have direct access
at runtime to the assets in there.

316
00:41:47,229 --> 00:41:54,390
I don't want to have a lot of runtime code which searches
by name and all this stuff because that's not very

317
00:41:54,849 --> 00:41:58,669
solid in the end; you'll get
a lot of errors from that.

318
00:42:13,909 --> 00:42:18,700
What I have here is basically a
simple scriptable object custom asset.

319
00:42:19,539 --> 00:42:26,659
And the core of this is it has a list of prefabs,
so this is a bundle manifest for prefabs.

320
00:42:27,510 --> 00:42:42,019
And it just realizes this list and provides a few
accesses for adding an object and accessing it by ID.

321
00:42:48,119 --> 00:42:50,400
The runtime equivalent of this.

322
00:42:50,500 --> 00:43:01,269
Once I build the bundle with that generated
manifest as the main asset of the bundle

323
00:43:01,269 --> 00:43:05,959
I can simply, once the bundle has been downloaded,

324
00:43:05,959 --> 00:43:08,929
I can go in and

325
00:43:10,729 --> 00:43:17,429
basically cast the main asset of
the bundle to my manifest type.

326
00:43:17,429 --> 00:43:24,779
And once I have that, I can ask the
reference to that manifest to give me

327
00:43:24,779 --> 00:43:32,719
the prefab reference based on
the ID that I already know.

328
00:43:32,719 --> 00:43:40,699
So there's no searching for anything; it's just an ID
which I can store in my build process of the bundle.

329
00:43:50,049 --> 00:43:53,779
Here's an example of prefab bundle use.

330
00:43:55,559 --> 00:43:58,980
The goal here is still the
same natural workflow

331
00:43:58,980 --> 00:44:04,569
a simple deploy build method.

332
00:44:04,569 --> 00:44:12,620
And the way I've set it up here is,
I have this ".prefabBundle" folder

333
00:44:13,549 --> 00:44:22,009
and my build script just goes in and finds all
prefabs in any folder called ".prefabBundle"

334
00:44:22,920 --> 00:44:29,169
So this is the original prefab which
has a box collider and a cube on it.

335
00:44:29,169 --> 00:44:37,359
And once my build script runs, it populates
the manifest here as we saw before,

336
00:44:37,359 --> 00:44:43,459
so there's a reference to my
prefab here, and it has an ID.

337
00:44:44,989 --> 00:44:51,419
What it then does is it
creates a reference prefab.

338
00:44:51,419 --> 00:44:56,859
So the nice setup here is that I can continue building
my game using prefabs like I normally would

339
00:44:56,859 --> 00:45:01,439
without worrying about having
to use bundles later on

340
00:45:01,439 --> 00:45:05,989
I can just go build my bundles, or
go build my scenes with prefabs

341
00:45:05,989 --> 00:45:11,900
put those prefabs, which I want to bundle
up, put them in a prefabBundle folder

342
00:45:11,900 --> 00:45:22,589
and my build process then automatically replaces the instances
in my scene with these reference bundles or reference prefabs.

343
00:45:22,589 --> 00:45:27,959
So if we exit play mode
here, you can see

344
00:45:39,849 --> 00:45:44,629
initially my amazing cube here,
since it has been built

345
00:45:45,949 --> 00:45:50,050
I have this bundle prefab reference
which holds the bundle ID

346
00:45:51,309 --> 00:45:53,739
and the prefab ID within that bundle.

347
00:45:53,739 --> 00:46:00,369
But other than that, any other information
has now been pushed to the bundle.

348
00:46:00,369 --> 00:46:03,389
So this means when we load this up

349
00:46:03,389 --> 00:46:05,599
you see that the cube
appears a bit later

350
00:46:05,599 --> 00:46:15,439
as the bundle is loaded and instantiated
based on the data in the reference.

351
00:46:15,439 --> 00:46:17,590
Here's another example of bundle use.

352
00:46:17,590 --> 00:46:21,920
Normally you cannot include any
additional code in a bundle.

353
00:46:21,920 --> 00:46:26,749
All your code has to be
built into the core game

354
00:46:28,199 --> 00:46:34,959
and any additional assets can
then be put in an asset bundle.

355
00:46:34,959 --> 00:46:38,490
However, there are several cases
where you might want to

356
00:46:38,490 --> 00:46:42,579
put some code in bundles, such as if
you have an additional character

357
00:46:42,579 --> 00:46:49,019
or weapon or something like this
which has some custom logic to it.

358
00:46:49,989 --> 00:46:55,239
You want to continue with your familiar workflow
of having all your scripts in the same project.

359
00:46:55,239 --> 00:47:02,429
Not all of them compiling to your main
project, but the same kind of workflow.

360
00:47:04,659 --> 00:47:09,529
The way I've gone about
implementing this is I have

361
00:47:09,529 --> 00:47:18,150
put a folder called "script bundles" in the
folder called "Assets/WebPlayer templates."

362
00:47:18,150 --> 00:47:22,129
And the important thing about
this particular folder

363
00:47:22,129 --> 00:47:29,319
is that for the folder WebPlayer templates,
the compiler and all importers are turned off.

364
00:47:29,319 --> 00:47:34,219
The reason for this is WebPlayer templates
might contain JavaScript code

365
00:47:34,219 --> 00:47:36,999
which is website JavaScript

366
00:47:36,999 --> 00:47:42,469
so you of course don't want this
compiled in with your main project.

367
00:47:42,469 --> 00:47:45,870
But we're taking advantage of that fact

368
00:47:46,719 --> 00:47:49,399
and putting a script
bundle folder in there

369
00:47:49,399 --> 00:47:57,409
and my build script then goes over
all subfolders of this folder

370
00:47:58,259 --> 00:48:03,249
and taking all the scripts found in there,
and compiling them to a .net assembly

371
00:48:03,249 --> 00:48:08,799
using a very similar technique to the one
you saw used for Java compiling before.

372
00:48:08,799 --> 00:48:20,869
So I basically used the .net process setup to invoke the .net
compiler that was shipped with Unity, and built in assembly.

373
00:48:20,869 --> 00:48:31,489
And this assembler saves it out as a text
asset by calling it "myassembly.bytes"

374
00:48:31,489 --> 00:48:36,489
That extension makes Unity
import it as a text asset

375
00:48:36,489 --> 00:48:44,259
but it doesn't do an text encoding on it,
so you don't lose any important binary data.

376
00:48:44,259 --> 00:48:48,229
But it means I can include that
asset in an asset bundle

377
00:48:49,289 --> 00:48:52,979
and then access it as a text
bundle and load it into memory.

378
00:48:52,979 --> 00:48:59,979
And I can show you this in a minute.

379
00:49:04,129 --> 00:49:15,329
If we go to the bundle manager...

380
00:49:17,499 --> 00:49:21,429
This is the bundle manager
we took a look at before

381
00:49:22,719 --> 00:49:25,350
I have a core routine
into load a type

382
00:49:25,350 --> 00:49:27,779
which basically initially
loads the bundle.

383
00:49:29,189 --> 00:49:32,679
And once it's available...

384
00:49:35,929 --> 00:49:45,829
Once it's available, I access the main asset
for this which is the assembly that I've built.

385
00:49:45,829 --> 00:49:49,359
And that's a text asset,
so I can cast it.

386
00:49:49,359 --> 00:49:53,629
And accessing its .bytes property gives me

387
00:49:53,629 --> 00:50:00,489
a bytes array which I can pass
into the .net assembly. Load.

388
00:50:00,489 --> 00:50:08,999
From within this, I can get
the type that I'm looking for.

389
00:50:09,199 --> 00:50:12,409
So if we look at the
code that uses this...

390
00:50:28,259 --> 00:50:33,319
Here I ask the bundle
manager to load

391
00:50:33,319 --> 00:50:38,440
the type "NewBehaviorScript" from within
the bundle called "BestScriptsEver."

392
00:50:38,440 --> 00:50:46,449
And once it's done, I want this method
called "OnReceiveType" to be invoked.

393
00:50:46,449 --> 00:50:52,089
This will pass me the string that I used to
search for the type, plus the type itself.

394
00:50:52,089 --> 00:50:59,439
Once I have that type reference, I can simply
add it as a component to my current game object.

395
00:50:59,439 --> 00:51:03,919
The result of which, you can see here.

396
00:51:03,919 --> 00:51:05,989
You can see there's an
additional script here

397
00:51:05,989 --> 00:51:10,130
which Unity has no information on;
There's no script name or anything

398
00:51:10,130 --> 00:51:13,619
because it's a component
we have loaded at runtime.

399
00:51:14,949 --> 00:51:16,750
A bit more interesting than this.

400
00:51:16,750 --> 00:51:22,679
If you check in the log, there are two log
messages here: One called "We're in!"

401
00:51:22,679 --> 00:51:26,449
and then one saying "From
a script bundle even."

402
00:51:27,310 --> 00:51:38,609
The way this is set up is, if we look at the
code for the component I've compiled in here

403
00:51:38,609 --> 00:51:42,319
you can see I have to log
messages, the two that we saw

404
00:51:42,319 --> 00:51:48,269
but one is within a pre-compiler define.

405
00:51:48,269 --> 00:51:53,259
So this allows you to, once you
automatically build your bundle, you can

406
00:51:53,259 --> 00:51:58,249
have logic separated between
whether it's in a bundle or not.

407
00:51:58,249 --> 00:52:03,779
Of course since you're just invoking the .net
compiler, you can have all sorts of additional setup.

408
00:52:03,779 --> 00:52:14,259
One I suggest is, for instance, include resources
from the same folder as references on the assembly.

409
00:52:21,029 --> 00:52:23,180
Okay, so just in summary.

410
00:52:23,180 --> 00:52:30,639
This is, as I mentioned, a somewhat
practical counterpart from last year's talk

411
00:52:31,969 --> 00:52:34,470
I hope this was
inspirational and useful.

412
00:52:35,519 --> 00:52:42,679
Of course, once the Asia tour is done, all this code
and examples and all that stuff will be available.

413
00:52:43,859 --> 00:52:50,379
More than that, I hope that you'll go
home and think about how you can use

414
00:52:50,379 --> 00:52:56,779
data you already have and code you already have for
different purposes to optimize productivity and workflow.

415
00:52:56,779 --> 00:53:05,739
Just to reiterate, this is about reuse and
re-application, and again, workflow.

416
00:53:05,739 --> 00:53:14,069
That's the end of my talk. If anyone has any questions, I think I
have like a minute or two. Otherwise, I'll be around for a while.

417
00:53:14,069 --> 00:53:21,069
And if need be, I'm sure we can find
someone to help translate. Thank you.

418
00:53:30,809 --> 00:53:34,039
Do we have time for questions?

419
00:53:34,039 --> 00:53:41,039
We have one question.

420
00:53:41,619 --> 00:53:44,569
No? Well that's easy!

421
00:53:44,569 --> 00:53:51,569
Oh, there's one here.

422
00:53:53,289 --> 00:54:08,879
[Speaking in Japanese]

423
00:54:08,879 --> 00:54:19,249
Yes. Basically, I might make subtle modifications
to this as I go through on the Asia Tour.

424
00:54:19,249 --> 00:54:27,039
And I think the plan is to release slides and examples at
the same time as we release the videos of the talks

425
00:54:27,969 --> 00:54:30,369
but this project is
already on GitHub

426
00:54:30,370 --> 00:54:36,269
I'm just waiting for videos to be available, and
then I flip that repository online or public.

427
00:54:36,769 --> 00:54:43,769
So yes, everything you see
here will be made available.

428
00:54:44,339 --> 00:54:48,029


429
00:54:48,029 --> 00:54:49,510
Okay, thank you for coming